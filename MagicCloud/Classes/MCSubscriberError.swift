//
//  MCSubscriberError.swift
//  MagicCloud
//
//  Created by James Lingo on 2/6/18.
//  Copyright Â© 2018 Escape Chaos. All rights reserved.
//

import CloudKit

/// This struct contains error handling for CKQuerySubscriptions. Currently only supports MCSubscriber class.
struct MCSubscriberError: MCRetrier {
    
    /// This optional property stores the MCSubscriber generating errors to be handled, when not nil.
    var delegate: MCSubscriber?
    
    /// This read-only, computed property returns delegate's database type, or publicDB if delegate is nil.
    var database: MCDatabase { return delegate?.database ?? .publicDB }
    
    /// This read-only, computed property returns delegate.subscription's recordType, or Mock's if delegate is nil.
    var recordType: String { return delegate?.subscription.recordType ?? "MockRecordable" }
    
    /**
        This function handles CKErrors resulting from failed subscription attempts.
    
        - Parameters:
            - error: The CKError generated by subscription, which requires handling.
            - isSubscribing: This argument is true when subscription is registering, false when unregistering.
            - id: The subscriptionID of subscription generating error, defaults nil. When nil, assumes error is coming from delegate's subscription.
     */
    func handle(_ error: CKError, whileSubscribing isSubscribing: Bool, to id: String? = nil) {
        
        // Subscription already exists.
        guard error.code != CKError.Code.serverRejectedRequest else {
            subscriptionAlreadyExists(retryAfter: error.retryAfterSeconds)
            return
        }
        
        if retriableErrors.contains(error.code), let duration = error.userInfo[CKErrorRetryAfterKey] as? TimeInterval {
            let q = DispatchQueue(label: retriableLabel)
            q.asyncAfter(deadline: .now() + duration) {
                isSubscribing ? self.delegate?.start() : self.delegate?.end(subscriptionID: id)
            }
        } else {
            // if not handled...
            let name = Notification.Name(MCErrorNotification)
            NotificationCenter.default.post(name: name, object: error)
        }
    }
    
    /**
        This void method deals with errors resulting from subscription type already existing in the database.
     
        - Parameter retryAfter: If nil, retries are immediate. Else, double is number of seconds retry is delayed.
     */
    func subscriptionAlreadyExists(retryAfter: Double?) {
        database.db.fetchAllSubscriptions { possibleSubscriptions, possibleError in
            
            // identify existing subscription...
            if let subs = possibleSubscriptions {
                switch subs.count {
                case 0: self.attemptCreateSubscriptionAgain(after: retryAfter)
                case 1: break   // <-- Do NOTHING; leaves solitary subscription in place.
                default: self.leaveOnlyFirstSubscription(in: subs)
                }
            }
        }
    }
    
    /**
        This void method attempts to reregister subscription. Theoretically, would only trigger in the event that there are no same type subscriptions...but that should never occur. Maintained as a safety, but may be deprecated in the future.
     
        - Parameter retryAfter: If nil, retries are immediate. Else, double is number of seconds retry is delayed.
     */
    func attemptCreateSubscriptionAgain(after retryAfter: Double?) {
        print("MCSubscriber.attemptCreateSubscriptionAgain ...SHOULD NEVER TRIGGER")
 
        let delay = retryAfter ?? 1
        let q = DispatchQueue(label: self.retriableLabel)
        q.asyncAfter(deadline: .now() + delay) { self.delegate?.start() }
    }
    
    /**
        This void method removes all but one subscription of the same type.
     
        - Parameter subs: An array of subscriptions that need to be unregistered, save one.
     */
    func leaveOnlyFirstSubscription(in subs: [CKSubscription]) {
        var isNotFirst = false
        for sub in subs {
            if let subscription = sub as? CKQuerySubscription,
                subscription.recordType == self.delegate?.subscription.recordType,
                subscription.querySubscriptionOptions == self.delegate?.subscription.querySubscriptionOptions {

                // delete the subscription...
                isNotFirst ? (self.delegate?.end(subscriptionID: sub.subscriptionID)) : (isNotFirst = true)
            }
        }
    }
}
